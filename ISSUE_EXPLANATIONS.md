# 问题解释和修复说明

## 问题1: Market卖出可能有多笔成交单 ⚠️ **已修复**

### 问题说明
Market订单可能被拆分成多笔成交，每笔成交的价格可能不同：
- 例如：卖出100个币，可能分成：
  - 50个 @ $100
  - 30个 @ $99.8  
  - 20个 @ $99.5

### 之前的处理方式
只使用 `get_order()` API 返回的 `fillPx`，这可能是平均价，但不够精确。

### 修复方案
**简化方案**：直接使用 `get_order()` API 返回的 `fillPx`
- OKX官方API的 `fillPx` 已经是所有成交的加权平均价
- 不需要额外调用 `get_fills()` 计算
- 更简单、更高效

**调用时机**：
1. 卖出订单提交后
2. 等待0.5秒（确保订单处理完成）
3. 调用 `get_order()` 获取订单信息
4. 使用返回的 `fillPx` 作为卖出价格

### 代码位置
`websocket_limit_trading.py` 的 `sell_market_order()` 函数

---

## 问题2: 参考价格应该是每小时开盘价 ⚠️ **已修复**

### 问题说明
**重要发现**：策略是每小时交易（买入后，下一个整点小时卖出），所以：
- ❌ **之前错误**：使用每日开盘价（`bar="1D"`）
- ✅ **正确做法**：使用当前小时的开盘价（`bar="1H"`）

**为什么重要**：
- 例如：10:00买入，11:00卖出
- 应该用10:00这个小时的开盘价（10:00:00的价格）作为参考
- 而不是今天00:00的开盘价

### 修复方案
1. 改为使用 `bar="1H"` 获取当前小时的K线
2. 使用当前小时的开盘价作为参考价格
3. 每小时刷新一次参考价格（而不是每天）

### 代码位置
- `fetch_current_hour_open_price()` - 获取当前小时开盘价
- `initialize_reference_prices()` - 初始化参考价格
- `main()` - 每小时刷新参考价格

---

## 问题3: 参考价格获取失败处理 ⚠️ **已修复**

### 问题说明
当无法获取当前小时开盘价时：
- **之前的行为**：使用当前价格作为参考价格
- **问题**：如果当前价格已经下跌了10%，使用当前价格作为参考会导致：
  ```
  限价 = 当前价格 × 95% = 已下跌的价格 × 95%
  ```
  这样会立即触发买入，不是期望的行为。

### 修复方案
**改为跳过本次检查**，等待下次tick再重试：
- 优点：避免错误的触发
- 缺点：如果API一直失败，可能错过买入机会
- 权衡：相比错误触发，错过机会更安全

### 代码位置
`websocket_limit_trading.py` 的 `on_ticker_message()` 函数

---

## 问题4: 重复卖出保护 ⚠️ **已修复**

### 问题说明
**场景**：
1. 整点时刻，K线确认消息到达
2. `on_candle_message()` 收到 `confirm='1'`
3. 启动线程调用 `process_sell_signal()`
4. **但** WebSocket可能重复发送相同的确认消息
5. 如果收到2次确认，会启动2个线程，可能卖出2次！

### 修复方案
添加 `sell_triggered` 标志防止重复触发：

```python
# 在 active_orders 中添加标志
active_orders[instId] = {
    "ordId": "...",
    "sell_triggered": False,  # 标记是否已触发卖出
    ...
}

# 在 on_candle_message() 中检查
with lock:
    if active_orders[instId].get("sell_triggered", False):
        return  # 已经触发过，跳过
    active_orders[instId]["sell_triggered"] = True  # 标记为已触发
```

### 保护层级
1. **第一层**：`sell_triggered` 标志（在接收消息时）
2. **第二层**：数据库状态检查（在 `process_sell_signal()` 中）
3. **第三层**：`active_orders` 清理（卖出成功后删除）

### 代码位置
- `on_candle_message()` - 添加标志检查
- `process_buy_signal()` - 初始化标志

---

## 问题5: 参考价格fallback的问题 ⚠️ **已修复**

### 问题说明
这是问题2的延伸。当前修复方案已经改为**跳过而不是fallback**。

### 为什么之前建议改进
之前使用当前价格作为fallback，但在以下场景有问题：

**场景示例**：
1. 今日开盘价：$100
2. 价格下跌到：$90（已跌10%）
3. 参考价格获取失败
4. 使用当前价格 $90 作为参考
5. 限价 = $90 × 95% = $85.5
6. 当前价格 $90 > $85.5，**不会触发**（这是对的）

**但是**，如果：
1. 价格继续下跌到：$85
2. 限价仍然是 $85.5（因为参考价格还是 $90）
3. $85 < $85.5，**会触发**（可能不是期望的）

### 当前修复方案
**跳过本次检查**，这样：
- 不会使用错误的参考价格
- 下次tick会重试获取正确的参考价格
- 如果API恢复正常，会使用正确的开盘价

### 可选改进（未来）
如果需要更智能的处理：
1. **缓存最后一次成功的参考价格**
2. **使用缓存的价格**（如果获取失败）
3. **设置过期时间**（例如：如果缓存超过1小时，不使用）

但当前方案（跳过）已经足够安全和正确。

---

## 总结

| 问题 | 状态 | 说明 |
|------|------|------|
| 多笔成交单处理 | ✅ 已修复 | 简化：直接使用 `get_order()` 的 `fillPx`（OKX已计算加权平均） |
| 参考价格（每小时） | ✅ 已修复 | 改为使用每小时开盘价，而不是每日开盘价 |
| 参考价格fallback | ✅ 已修复 | 改为跳过而不是使用当前价格 |
| 重复卖出保护 | ✅ 已修复 | 添加 `sell_triggered` 标志 |
| 参考价格缓存 | 📝 可选改进 | 未来可以考虑缓存机制 |

---

## 测试建议

### 测试1: 多笔成交单
1. 设置小金额卖出（容易触发多笔成交）
2. 观察日志中是否显示 "weighted avg price from X fills"
3. 验证计算的加权平均价是否正确

### 测试2: 参考价格失败
1. 模拟API失败（断开网络或修改API endpoint）
2. 观察日志：应该看到 "skipping buy check" 而不是触发买入

### 测试3: 重复卖出保护
1. 手动模拟发送多个K线确认消息
2. 验证只卖出一次
3. 检查日志：应该看到 "Sell already triggered" 消息
